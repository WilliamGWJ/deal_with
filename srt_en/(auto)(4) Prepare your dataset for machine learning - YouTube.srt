1
00:00:01,070 --> 00:00:01,640
[Music]

2
00:00:01,640 --> 00:00:03,259
[Applause]

3
00:00:03,259 --> 00:00:05,970
hi and welcome to coding tensorflow

4
00:00:05,970 --> 00:00:08,130
a show where we focus on coding machine

5
00:00:08,130 --> 00:00:10,230
learning and AI applications I'm

6
00:00:10,230 --> 00:00:12,090
Laurence Moroney a developer advocate

7
00:00:12,090 --> 00:00:13,080
for tensorflow

8
00:00:13,080 --> 00:00:15,120
and in this episode were going to look

9
00:00:15,120 --> 00:00:17,039
at using JavaScript for machine learning

10
00:00:17,039 --> 00:00:19,500
in the browser in the previous episode

11
00:00:19,500 --> 00:00:21,480
we looked at creating a very basic

12
00:00:21,480 --> 00:00:23,430
machine learning scenario in the browser

13
00:00:23,430 --> 00:00:25,890
you took data that had a linear

14
00:00:25,890 --> 00:00:28,289
relationship and built a basic model

15
00:00:28,289 --> 00:00:30,090
that could predict future values based

16
00:00:30,090 --> 00:00:32,640
on that relationship it might have

17
00:00:32,640 --> 00:00:34,530
looked a little strange in how you fed

18
00:00:34,530 --> 00:00:36,090
the data into the model when you were

19
00:00:36,090 --> 00:00:38,100
training it with one tensor of the

20
00:00:38,100 --> 00:00:40,290
x-values and another for the y-values

21
00:00:40,290 --> 00:00:42,870
that's because one of the core concepts

22
00:00:42,870 --> 00:00:44,399
that you need to learn as a tensorflow

23
00:00:44,399 --> 00:00:47,520
developer is all about that how to shape

24
00:00:47,520 --> 00:00:49,260
your data and how to get it ready for

25
00:00:49,260 --> 00:00:52,649
training this process is a major part of

26
00:00:52,649 --> 00:00:55,379
data science and today we'll look at a

27
00:00:55,379 --> 00:00:57,690
more complex program and how you can get

28
00:00:57,690 --> 00:00:59,670
your data ready for training a machine

29
00:00:59,670 --> 00:01:02,219
learn model with it so instead of a

30
00:01:02,219 --> 00:01:04,290
simple linear arrangement which you

31
00:01:04,290 --> 00:01:05,570
don't really need machine learning for

32
00:01:05,570 --> 00:01:08,280
let's consider a classification problem

33
00:01:08,280 --> 00:01:10,409
and this is when there are multiple

34
00:01:10,409 --> 00:01:13,260
items of data about a thing and then

35
00:01:13,260 --> 00:01:14,909
there's something about how they're

36
00:01:14,909 --> 00:01:16,909
related that determines the

37
00:01:16,909 --> 00:01:20,100
classification of that thing so for

38
00:01:20,100 --> 00:01:22,860
example an email might be a spam if it's

39
00:01:22,860 --> 00:01:25,409
from a particular sender or it contains

40
00:01:25,409 --> 00:01:27,530
particular keywords or pictures an

41
00:01:27,530 --> 00:01:30,570
animal might be a doggie if it has four

42
00:01:30,570 --> 00:01:33,570
paws and a cute wet nose now it's very

43
00:01:33,570 --> 00:01:36,390
difficult to program traditional if-then

44
00:01:36,390 --> 00:01:38,970
type code for these scenarios and this

45
00:01:38,970 --> 00:01:40,710
is why machine learning can be such a

46
00:01:40,710 --> 00:01:43,350
powerful tool so let's take a look at

47
00:01:43,350 --> 00:01:45,270
some public data and we'll use that to

48
00:01:45,270 --> 00:01:48,119
build a classification system we're

49
00:01:48,119 --> 00:01:50,479
going to use the well-known iris dataset

50
00:01:50,479 --> 00:01:52,890
which collects data points from a

51
00:01:52,890 --> 00:01:54,780
hundred and fifty different samples of

52
00:01:54,780 --> 00:01:57,750
flower taking petal length and width as

53
00:01:57,750 --> 00:02:00,570
well as sepal length and width these

54
00:02:00,570 --> 00:02:02,850
measurements are then associated with

55
00:02:02,850 --> 00:02:06,479
one of three types of iris by training a

56
00:02:06,479 --> 00:02:08,220
neural network with these measurements

57
00:02:08,220 --> 00:02:10,920
telling it the values and then the

58
00:02:10,920 --> 00:02:12,800
classes of flower the chorus

59
00:02:12,800 --> 00:02:15,170
to those values you could then build a

60
00:02:15,170 --> 00:02:18,140
neural network that can infer from a new

61
00:02:18,140 --> 00:02:20,180
measurement what type of flower they

62
00:02:20,180 --> 00:02:22,520
represent so let's take a look at the

63
00:02:22,520 --> 00:02:24,680
data and here it is and you might

64
00:02:24,680 --> 00:02:26,930
typically get data like this as a bunch

65
00:02:26,930 --> 00:02:30,110
of comma separated values as you can see

66
00:02:30,110 --> 00:02:32,810
each entry has five values the four

67
00:02:32,810 --> 00:02:34,190
measurements that I mentioned earlier

68
00:02:34,190 --> 00:02:37,460
and then a value zero one or two in the

69
00:02:37,460 --> 00:02:40,040
final column indicating the category of

70
00:02:40,040 --> 00:02:43,250
flower that the data represents consider

71
00:02:43,250 --> 00:02:45,620
the first four values to be your X's and

72
00:02:45,620 --> 00:02:49,280
the last one is your Y thus given a set

73
00:02:49,280 --> 00:02:51,680
of four X's you'd want to predict or

74
00:02:51,680 --> 00:02:54,740
classify the Y so now that you have the

75
00:02:54,740 --> 00:02:57,620
data you can use it to train a model to

76
00:02:57,620 --> 00:02:59,660
do that you'll use tensors for the

77
00:02:59,660 --> 00:03:02,090
training X's and tensors for the

78
00:03:02,090 --> 00:03:05,120
training wise in addition to that you

79
00:03:05,120 --> 00:03:07,130
can use some of your data to test your

80
00:03:07,130 --> 00:03:09,530
model so what you should do is you take

81
00:03:09,530 --> 00:03:11,180
your percentage of your data for

82
00:03:11,180 --> 00:03:13,160
training the model and then with the

83
00:03:13,160 --> 00:03:15,770
remainder compare the predicted value

84
00:03:15,770 --> 00:03:18,380
with their actual value and from there

85
00:03:18,380 --> 00:03:20,300
you can determine how well your model is

86
00:03:20,300 --> 00:03:23,120
behaving so let's take a look at the

87
00:03:23,120 --> 00:03:25,220
code that we use to prepare this data

88
00:03:25,220 --> 00:03:27,860
for training first of all we'll split

89
00:03:27,860 --> 00:03:30,050
the data into different arrays for each

90
00:03:30,050 --> 00:03:33,230
of the classes this for loop iterates

91
00:03:33,230 --> 00:03:36,200
through the iris classes length and it

92
00:03:36,200 --> 00:03:38,540
creates two arrays one for the data of

93
00:03:38,540 --> 00:03:40,610
that class and one for the values for

94
00:03:40,610 --> 00:03:43,130
that class if you then look at the data

95
00:03:43,130 --> 00:03:45,560
you'll see that there are three classes

96
00:03:45,560 --> 00:03:49,250
so we'll have three of each array the

97
00:03:49,250 --> 00:03:51,709
data by class will contain the four

98
00:03:51,709 --> 00:03:54,200
measurements and the targets by class

99
00:03:54,200 --> 00:03:57,530
will contain zero one or two based on

100
00:03:57,530 --> 00:04:00,650
the flower type once we've created these

101
00:04:00,650 --> 00:04:02,900
arrays we can now iterate through the

102
00:04:02,900 --> 00:04:05,840
data and sort the values into the array

103
00:04:05,840 --> 00:04:09,170
based on the target so the data for

104
00:04:09,170 --> 00:04:11,930
class 0 will get loaded into data by

105
00:04:11,930 --> 00:04:14,660
class 0 and the targets for class 0

106
00:04:14,660 --> 00:04:19,250
likewise etc etc if I now log these

107
00:04:19,250 --> 00:04:21,739
arrays to the console I can view them in

108
00:04:21,739 --> 00:04:29,559
my developer tools

109
00:04:29,559 --> 00:04:32,259
the next step will be to convert these

110
00:04:32,259 --> 00:04:35,049
values into tensors with four sets of

111
00:04:35,049 --> 00:04:38,199
tensors an X for training annex for test

112
00:04:38,199 --> 00:04:42,069
a Y for training and a y4 test we do

113
00:04:42,069 --> 00:04:44,619
this according to the test split which

114
00:04:44,619 --> 00:04:46,119
is a parameter that we pass into the

115
00:04:46,119 --> 00:04:48,519
function in this demo I said it's a

116
00:04:48,519 --> 00:04:51,759
point two so that 80% of my data is used

117
00:04:51,759 --> 00:04:55,209
for training and 20% for testing the

118
00:04:55,209 --> 00:04:57,639
workhorse here is the convert to tensors

119
00:04:57,639 --> 00:05:00,849
function this takes the data the targets

120
00:05:00,849 --> 00:05:03,399
and the split and loads all this value

121
00:05:03,399 --> 00:05:05,349
into tensors splitting them into

122
00:05:05,349 --> 00:05:07,359
training and test sets respectively

123
00:05:07,359 --> 00:05:10,139
let's take a look at that next

124
00:05:10,139 --> 00:05:12,789
here is the convert to tensors function

125
00:05:12,789 --> 00:05:14,829
it calculates the number of test

126
00:05:14,829 --> 00:05:17,649
examples by rounding the sample size by

127
00:05:17,649 --> 00:05:20,139
the split and the number of training

128
00:05:20,139 --> 00:05:22,839
examples will just be the remainder it

129
00:05:22,839 --> 00:05:25,059
then creates a two dimensional tensor of

130
00:05:25,059 --> 00:05:27,759
the data as you can see here and a one

131
00:05:27,759 --> 00:05:31,599
heart encoding of the label data now one

132
00:05:31,599 --> 00:05:33,610
heart encoding is a way of helping a

133
00:05:33,610 --> 00:05:36,129
machine understand how your data is

134
00:05:36,129 --> 00:05:38,499
being classified so instead of the

135
00:05:38,499 --> 00:05:41,619
flowers being 0 1 or 2 what happens is

136
00:05:41,619 --> 00:05:43,839
you get an encoded array where instead

137
00:05:43,839 --> 00:05:47,319
of a flower for 0 you would get 1 0 0 in

138
00:05:47,319 --> 00:05:50,889
that array instead of 1 you get a 0 1 0

139
00:05:50,889 --> 00:05:54,549
etc etc the idea is this that that this

140
00:05:54,549 --> 00:05:56,589
array will just map to your output

141
00:05:56,589 --> 00:06:00,129
neurons once you've done that the data

142
00:06:00,129 --> 00:06:02,469
will be sliced into the four arrays

143
00:06:02,469 --> 00:06:04,779
based on the size determined by the test

144
00:06:04,779 --> 00:06:07,929
split the last step is just having a

145
00:06:07,929 --> 00:06:10,839
nice clean linear set of tensors to feed

146
00:06:10,839 --> 00:06:13,149
into the training instead of the 2d one

147
00:06:13,149 --> 00:06:14,189
that you have right now

148
00:06:14,189 --> 00:06:17,889
this is achieved using TF concat along

149
00:06:17,889 --> 00:06:20,439
axis 0 let's take a look at the code for

150
00:06:20,439 --> 00:06:24,039
this and here's the code you can see I

151
00:06:24,039 --> 00:06:26,979
set the concat access to be 0 and then

152
00:06:26,979 --> 00:06:29,739
I'll return my set of 4 tensors where

153
00:06:29,739 --> 00:06:31,629
i'm concatenating them into a one

154
00:06:31,629 --> 00:06:35,679
dimensional tensor as an example if i

155
00:06:35,679 --> 00:06:37,809
log the x trains against the

156
00:06:37,809 --> 00:06:40,179
concatenated x trains you'll see the

157
00:06:40,179 --> 00:06:42,289
difference this has the

158
00:06:42,289 --> 00:06:44,779
reducing the overall complexity of the

159
00:06:44,779 --> 00:06:47,300
data being fed into the model it doesn't

160
00:06:47,300 --> 00:06:49,069
have to try and figure out multiple

161
00:06:49,069 --> 00:06:51,110
dimensions and this makes training

162
00:06:51,110 --> 00:06:53,830
quicker and more accurate

163
00:06:53,830 --> 00:06:56,270
congratulations you've now taken raw

164
00:06:56,270 --> 00:06:58,009
data and you've learned how to

165
00:06:58,009 --> 00:07:01,039
pre-process it into tensors that make

166
00:07:01,039 --> 00:07:03,289
for efficient training including how to

167
00:07:03,289 --> 00:07:06,800
one heart encode the output data this is

168
00:07:06,800 --> 00:07:09,619
a massive part of designing any machine

169
00:07:09,619 --> 00:07:11,779
learning system getting your data right

170
00:07:11,779 --> 00:07:15,020
in the next video we'll train a neural

171
00:07:15,020 --> 00:07:17,629
network with this data and we'll see how

172
00:07:17,629 --> 00:07:20,180
you can design that network and then how

173
00:07:20,180 --> 00:07:22,039
you can do classification given the

174
00:07:22,039 --> 00:07:24,349
terrain model you can find that right

175
00:07:24,349 --> 00:07:26,119
here on the tensorflow youtube channel

176
00:07:26,119 --> 00:07:27,619
so don't forget to hit that subscribe

177
00:07:27,619 --> 00:07:30,140
button right now

178
00:07:30,140 --> 00:07:30,740
[Music]

179
00:07:30,740 --> 00:07:33,139
[Applause]

180
00:07:33,139 --> 00:07:35,199
you

